## Архітектурні принципи дизайну GC у .NET 10

Хоча ранні покоління .NET використовували класичний поколіннєвий GC, сучасний GC у .NET 10 являє собою складну гібридну систему, яка об'єднує:

- паралельний збір (parallel collection),
- фоновий збір (background GC),
- профайлинг живучості об'єктів,
- інтеграцію з JIT-компілятором,
- механізми прогнозування пікової памʼяті,
- новий AI-модуль адаптивного тюнінгу.

Мета GC у .NET 10 полягає не лише в очищенні памʼяті, а й у мінімізації **latency** — затримок, що впливають на продуктивність у реальному часі.

---

## Математична модель оптимізації затримок GC

Для моделювання роботи GC введемо наступні змінні:

- **T_gc** — загальна пауза GC (total pause time)
- **A(t)** — швидкість алокації об'єктів у часі
- **L(t)** — прогнозована живучість об'єктів
- **M_free** — доступна памʼять
- **P(AI)** — коефіцієнт корекції прогнозу на основі AI-моделі
- **C_compact** — вартість компактації

Тоді динамічна формула оцінки паузи у .NET 10 виглядає так:

\[
T_{gc} = \frac{A(t) \cdot L(t)}{M_{free}} \cdot P(AI) - \Delta C_{compact}
\]

де:

\[
\Delta C_{compact} = \frac{C_{compact}^{net8} - C_{compact}^{net10}}{C_{compact}^{net8}}
\]

У .NET 10 оптимізація write-barrier та покращена компактація зменшують **ΔC_compact** до значення 0.3–0.4 від попередніх версій.

---

## Mermaid-діаграма потоків роботи GC

```mermaid
flowchart TD
    A[Запуск процесу] --> B[Алокація об'єктів]
    B --> C{Переповнення покоління?}
    C -- Ні --> B
    C -- Так --> D[Mark Phase]
    D --> E[Sweep Phase]
    E --> F{Потрібна компактація?}
    F -- Так --> G[Compaction]
    F -- Ні --> H[Return to Execution]
    G --> H
    H --> B
