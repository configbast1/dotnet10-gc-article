## Потоки роботи Garbage Collector у .NET 10

Нижче наведена візуальна схема роботи збирача сміття (.NET 10 GC), яка ілюструє основні етапи:

- Алокація об'єктів у пам’яті
- Виявлення переповнення поколінь
- Mark Phase – позначення живих об’єктів
- Sweep Phase – видалення непотрібних об’єктів
- Compaction – ущільнення купи
- Повернення управління програмі

Для кращого відображення на GitHub рекомендується використовувати **зображення SVG**, яке можна вставити у статтю.

![Потоки GC](dotnet10_gc_flowchart.svg)

---

### Пояснення діаграми

1. **Запуск процесу:** початкове створення середовища виконання .NET та початкова алокація пам’яті.
2. **Алокація об'єктів:** стандартна робота програми, створення нових об’єктів у Generation 0.
3. **Переповнення покоління:** коли пам’ять покоління заповнена, GC активується.
4. **Mark Phase:** алгоритм позначає живі об’єкти.
5. **Sweep Phase:** видаляє всі непозначені об’єкти.
6. **Compaction:** ущільнення купи, переміщення живих об’єктів для зменшення фрагментації.
7. **Return to Execution:** управління повертається до основного потоку програми.

> **Примітка:** У .NET 10 GC працює паралельно з основним потоком програми, використовує AI для прогнозування пікової пам’яті та динамічно адаптує частоту збору сміття, що дозволяє зменшити паузи на 30–50%.

---

### Альтернатива: Mermaid код для локального перегляду

```mermaid
flowchart TD
    A[Запуск процесу] --> B[Алокація об'єктів]
    B --> C{Переповнення покоління?}
    C -- Ні --> B
    C -- Так --> D[Mark Phase]
    D --> E[Sweep Phase]
    E --> F{Потрібна компактація?}
    F -- Так --> G[Compaction]
    F -- Ні --> H[Return to Execution]
    G --> H
    H --> B
